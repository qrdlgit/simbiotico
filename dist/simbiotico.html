<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>jsMind</title>
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css?family=Roboto&display=swap"
      integrity="sha384-l06Plad51xhuxEwX9KBVJsB3YBeDeDhvs7QAa0vF9pUb+i2SA40QpPF55L6Rfrzq"
      crossorigin="anonymous"
    />

    <link rel="stylesheet" href="https://unpkg.com/jsmind@0.5.4/style/jsmind.css" integrity="sha384-1nTEMjWXLLPe1f1aBitnnwTmPw8N71MrZQQBMQn7ua9HnvdBZrPzhT1DMp2h+baG" crossorigin="anonymous">

    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css"
      integrity="sha384-/frq1SRXYH/bSyou/HUp/hib7RVN1TawQYja658FEOodR/FQBKVqT9Ol+Oz3Olq5"
      crossorigin="anonymous"
    />

    <style type="text/css">


                li {
                    margin-top: 2px;
                    margin-bottom: 2px;
                }
                button {
                    width: 140px;
                }
                select {
                    width: 140px;
                }
         .file_input {
                    width: 100px;
                }
                button.sub {
                    width: 100px;
                }

         body {
      margin: 0; !important
      padding: 0; !important
      position: relative;
      height: 100vh;
      overflow: hidden;
         }
    </style>

    <script src="https://unpkg.com/jsmind@0.5.4/js/jsmind.js" integrity="sha384-R5+m5beLoKFGYYfHYhJjZOFuYIfT3HUmn/8DwFvhVikHnGKsaBes0K45Zme67izm" crossorigin="anonymous"></script>
    

  </head>
  <body>
    <script>
  /**
 * @license BSD
 * @copyright 2014-2023 hizzgdev@163.com
 *
 * Project Home:
 *   https://github.com/hizzgdev/jsmind/
 */

  if (!jsMind) {
      throw new Error('jsMind is not defined');
  }

  const jm = jsMind;
  const $ = jm.$;

  const clear_selection =
	'getSelection' in $.w
        ? function () {
	    $.w.getSelection().removeAllRanges();
	}
        : function () {
	    $.d.selection.empty();
	};

  const options = {
      line_width: 5,
      lookup_delay: 500,
      lookup_interval: 80,
  };

  class DraggableNode {
      constructor(jm) {
	  this.jm = jm;
	  this.e_canvas = null;
	  this.canvas_ctx = null;
	  this.shadow = null;
	  this.shadow_w = 0;
	  this.shadow_h = 0;
	  this.active_node = null;
	  this.target_node = null;
	  this.target_direct = null;
	  this.client_w = 0;
	  this.client_h = 0;
	  this.offset_x = 0;
	  this.offset_y = 0;
	  this.hlookup_delay = 0;
	  this.hlookup_timer = 0;
	  this.capture = false;
	  this.moved = false;
	  this.canvas_draggable = this.jm.get_view_draggable();
      }
      init() {
	  this._create_canvas();
	  this._create_shadow();
	  this._event_bind();
      }
      resize() {
	  this.jm.view.e_nodes.appendChild(this.shadow);
	  this.e_canvas.width = this.jm.view.size.w;
	  this.e_canvas.height = this.jm.view.size.h;
      }
      _create_canvas() {
	  var c = $.c('canvas');
	  this.jm.view.e_panel.appendChild(c);
	  var ctx = c.getContext('2d');
	  this.e_canvas = c;
	  this.canvas_ctx = ctx;
      }
      _create_shadow() {
	  var s = $.c('jmnode');
	  s.style.visibility = 'hidden';
	  s.style.zIndex = '3';
	  s.style.cursor = 'move';
	  s.style.opacity = '0.7';
	  this.shadow = s;
      }
      reset_shadow(el) {
	  var s = this.shadow.style;
	  this.shadow.innerHTML = el.innerHTML;
	  s.left = el.style.left;
	  s.top = el.style.top;
	  s.width = el.style.width;
	  s.height = el.style.height;
	  s.backgroundImage = el.style.backgroundImage;
	  s.backgroundSize = el.style.backgroundSize;
	  s.transform = el.style.transform;
	  this.shadow_w = this.shadow.clientWidth;
	  this.shadow_h = this.shadow.clientHeight;
      }
      show_shadow() {
	  if (!this.moved) {
	      this.shadow.style.visibility = 'visible';
	  }
      }
      hide_shadow() {
	  this.shadow.style.visibility = 'hidden';
      }
      _magnet_shadow(node) {
	  if (!!node) {
	      this.canvas_ctx.lineWidth = options.line_width;
	      this.canvas_ctx.strokeStyle = 'rgba(255,255,255,0.3)';
	      this.canvas_ctx.lineCap = 'round';
	      this._clear_lines();
	      this._canvas_lineto(node.sp.x, node.sp.y, node.np.x, node.np.y);
	  }
      }
      _clear_lines() {
	  this.canvas_ctx.clearRect(0, 0, this.jm.view.size.w, this.jm.view.size.h);
      }
      _canvas_lineto(x1, y1, x2, y2) {
	  this.canvas_ctx.beginPath();
	  this.canvas_ctx.moveTo(x1, y1);
	  this.canvas_ctx.lineTo(x2, y2);
	  this.canvas_ctx.stroke();
      }
      _lookup_close_node() {
	  var root = this.jm.get_root();
	  var root_location = root.get_location();
	  var root_size = root.get_size();
	  var root_x = root_location.x + root_size.w / 2;

	  var sw = this.shadow_w;
	  var sh = this.shadow_h;
	  var sx = this.shadow.offsetLeft;
	  var sy = this.shadow.offsetTop;

	  var ns, nl;

	  var direct = sx + sw / 2 >= root_x ? jsMind.direction.right : jsMind.direction.left;
	  var nodes = this.jm.mind.nodes;
	  var node = null;
	  var layout = this.jm.layout;
	  var min_distance = Number.MAX_VALUE;
	  var distance = 0;
	  var closest_node = null;
	  var closest_p = null;
	  var shadow_p = null;
	  for (var nodeid in nodes) {
	      var np, sp;
	      node = nodes[nodeid];
	      if (node.isroot || node.direction == direct) {
		  if (node.id == this.active_node.id) {
		      continue;
		  }
		  if (!layout.is_visible(node)) {
		      continue;
		  }
		  ns = node.get_size();
		  nl = node.get_location();
		  if (direct == jsMind.direction.right) {
		      if (sx - nl.x - ns.w <= 0) {
			  continue;
		      }
		      distance = Math.abs(sx - nl.x - ns.w) + Math.abs(sy + sh / 2 - nl.y - ns.h / 2);
		      np = { x: nl.x + ns.w - options.line_width, y: nl.y + ns.h / 2 };
		      sp = { x: sx + options.line_width, y: sy + sh / 2 };
		  } else {
		      if (nl.x - sx - sw <= 0) {
			  continue;
		      }
		      distance = Math.abs(sx + sw - nl.x) + Math.abs(sy + sh / 2 - nl.y - ns.h / 2);
		      np = { x: nl.x + options.line_width, y: nl.y + ns.h / 2 };
		      sp = { x: sx + sw - options.line_width, y: sy + sh / 2 };
		  }
		  if (distance < min_distance) {
		      closest_node = node;
		      closest_p = np;
		      shadow_p = sp;
		      min_distance = distance;
		  }
	      }
	  }
	  var result_node = null;
	  if (!!closest_node) {
	      result_node = {
		  node: closest_node,
		  direction: direct,
		  sp: shadow_p,
		  np: closest_p,
	      };
	  }
	  return result_node;
      }
      lookup_close_node() {
	  var node_data = this._lookup_close_node();
	  if (!!node_data) {
	      this._magnet_shadow(node_data);
	      this.target_node = node_data.node;
	      this.target_direct = node_data.direction;
	  }
      }
      _event_bind() {
	  var jd = this;
	  var container = this.jm.view.container;
	  $.on(container, 'mousedown', function (e) {
	      var evt = e || event;
	      jd.dragstart.call(jd, evt);
	  });
	  $.on(container, 'mousemove', function (e) {
	      var evt = e || event;
	      jd.drag.call(jd, evt);
	  });
	  $.on(container, 'mouseup', function (e) {
	      var evt = e || event;
	      jd.dragend.call(jd, evt);
	  });
	  $.on(container, 'touchstart', function (e) {
	      var evt = e || event;
	      jd.dragstart.call(jd, evt);
	  });
	  $.on(container, 'touchmove', function (e) {
	      var evt = e || event;
	      jd.drag.call(jd, evt);
	  });
	  $.on(container, 'touchend', function (e) {
	      var evt = e || event;
	      jd.dragend.call(jd, evt);
	  });
      }
      dragstart(e) {
	  if (!this.jm.get_editable()) {
	      return;
	  }
	  if (this.capture) {
	      return;
	  }
	  this.active_node = null;
	  this.view_draggable = this.jm.get_view_draggable();

	  var jview = this.jm.view;
	  var el = e.target || event.srcElement;
	  if (el.tagName.toLowerCase() != 'jmnode') {
	      return;
	  }
	  if (this.view_draggable) {
	      this.jm.disable_view_draggable();
	  }
	  var nodeid = jview.get_binded_nodeid(el);
	  if (!!nodeid) {
	      var node = this.jm.get_node(nodeid);
	      if (!node.isroot) {
		  this.reset_shadow(el);
		  this.active_node = node;
		  this.offset_x =
		      (e.clientX || e.touches[0].clientX) / jview.actualZoom - el.offsetLeft;
		  this.offset_y =
		      (e.clientY || e.touches[0].clientY) / jview.actualZoom - el.offsetTop;
		  this.client_hw = Math.floor(el.clientWidth / 2);
		  this.client_hh = Math.floor(el.clientHeight / 2);
		  if (this.hlookup_delay != 0) {
		      $.w.clearTimeout(this.hlookup_delay);
		  }
		  if (this.hlookup_timer != 0) {
		      $.w.clearInterval(this.hlookup_timer);
		  }
		  var jd = this;
		  this.hlookup_delay = $.w.setTimeout(function () {
		      jd.hlookup_delay = 0;
		      jd.hlookup_timer = $.w.setInterval(function () {
			  jd.lookup_close_node.call(jd);
		      }, options.lookup_interval);
		  }, options.lookup_delay);
		  this.capture = true;
	      }
	  }
      }
      drag(e) {
	  if (!this.jm.get_editable()) {
	      return;
	  }
	  if (this.capture) {
	      e.preventDefault();
	      this.show_shadow();
	      this.moved = true;
	      clear_selection();
	      var jview = this.jm.view;
	      var px = (e.clientX || e.touches[0].clientX) / jview.actualZoom - this.offset_x;
	      var py = (e.clientY || e.touches[0].clientY) / jview.actualZoom - this.offset_y;
	      this.shadow.style.left = px + 'px';
	      this.shadow.style.top = py + 'px';
	      clear_selection();
	  }
      }
      dragend(e) {
	  if (!this.jm.get_editable()) {
	      return;
	  }
	  if (this.view_draggable) {
	      this.jm.enable_view_draggable();
	  }
	  if (this.capture) {
	      if (this.hlookup_delay != 0) {
		  $.w.clearTimeout(this.hlookup_delay);
		  this.hlookup_delay = 0;
		  this._clear_lines();
	      }
	      if (this.hlookup_timer != 0) {
		  $.w.clearInterval(this.hlookup_timer);
		  this.hlookup_timer = 0;
		  this._clear_lines();
	      }
	      if (this.moved) {
		  var src_node = this.active_node;
		  var target_node = this.target_node;
		  var target_direct = this.target_direct;
		  this.move_node(src_node, target_node, target_direct);
	      }
	      this.hide_shadow();
	  }
	  this.moved = false;
	  this.capture = false;
      }
      move_node(src_node, target_node, target_direct) {
	  var shadow_h = this.shadow.offsetTop;
	  if (!!target_node && !!src_node && !jsMind.node.inherited(src_node, target_node)) {
	      // lookup before_node
	      var sibling_nodes = target_node.children;
	      var sc = sibling_nodes.length;
	      var node = null;
	      var delta_y = Number.MAX_VALUE;
	      var node_before = null;
	      var beforeid = '_last_';
	      while (sc--) {
		  node = sibling_nodes[sc];
		  if (node.direction == target_direct && node.id != src_node.id) {
		      var dy = node.get_location().y - shadow_h;
		      if (dy > 0 && dy < delta_y) {
			  delta_y = dy;
			  node_before = node;
			  beforeid = '_first_';
		      }
		  }
	      }
	      if (!!node_before) {
		  beforeid = node_before.id;
	      }
	      this.jm.move_node(src_node.id, beforeid, target_node.id, target_direct);
	  }
	  this.active_node = null;
	  this.target_node = null;
	  this.target_direct = null;
      }
      jm_event_handle(type, data) {
	  if (type === jsMind.event_type.resize) {
	      this.resize();
	  }
      }
  }

  var draggable_plugin = new jm.plugin('draggable_node', function (jm) {
      var jd = new DraggableNode(jm);
      jd.init();
      jm.add_event_listener(function (type, data) {
	  jd.jm_event_handle.call(jd, type, data);
      });
  });

  jsMind.register_plugin(draggable_plugin);
  
</script>

    <script>

  class UndoRedoManager {
      constructor(maxSize) {
	  this.undoStack = [];
	  this.redoStack = [];
	  this.maxSize = maxSize;
      }

      performAction(state) {
	  this.undoStack.push(JSON.parse(JSON.stringify(state)));

	  if (this.undoStack.length > this.maxSize) {
              this.undoStack.shift();
	  }

	  this.redoStack = [];
      }

      undo(cur) {
	  if (this.undoStack.length === 0) {
              return null;
	  }

	  var prevState = this.undoStack.pop();
	  if (this.undoStack.length === 0) {
	      this.undoStack.push(prevState);
	  }
	  if (prevState == cur) {
	      if (this.undoStack.length < 2) {
		  return null;
	      } else {
		  return undo(cur);
	      }
	  }
	  this.redoStack.push(JSON.parse(JSON.stringify(prevState)));
	  return prevState;
      }

      redo() {
	  if (this.redoStack.length === 0) {
              return null;
	  }

	  const nextState = this.redoStack.pop();
	  this.undoStack.push(JSON.parse(JSON.stringify(nextState)));
	  return nextState;
      }
  }


  function createUpdatePopupSize(maxHeight, maxWidth, div) {
      return function () {
	  const windowHeight = window.innerHeight;
	  if (windowHeight < maxHeight) {
	      div.style.height = (windowHeight * 0.9) + "px"; // Set popup height to 80% of the window height
	  } else {
	      div.style.height = maxHeight;
	  }
	  const windowWidth = window.innerWidth;
	  if (windowWidth < maxWidth) {
	      div.style.width = (windowWidth * 0.9) + "px"; // Set popup height to 80% of the window height
	  } else {
	      div.style.width = maxWidth; // Reset the popup height to auto when the window is larger
	  }
      };
  }
  

  function setupPopSizeListener(maxHeight, maxWidth, popup) {
      const updatePopupSize = createUpdatePopupSize(maxHeight, maxWidth, popup);

      // Call updatePopupHeight on window resize
      window.addEventListener("resize", updatePopupSize);

      // Call updatePopupHeight on page load
      updatePopupSize();
            
  }
  
  const undoRedoManager = new UndoRedoManager(20);

 </script>

    <style>
  .help-popup {
    position: fixed;
    top: 60px;
    right: 60px;
    width: 600px;
    max-height: 750px;
    background: white;
    border: 1px solid #ccc;
    border-radius: 5px;
    display: flex;
    flex-direction: column;
    z-index: 1000;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
  }

  .help-popup-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 5px;
    background: #0066ff;
    color: white;
    font-weight: bold;
    border-top-left-radius: 5px;
    border-top-right-radius: 5px; 
    font-family: "Roboto", sans-serif;
   max-height: 35px;
  }

  .help-popup-header h3 {
    margin: 0;
    font-family: "Roboto", sans-serif;
    font-weight: 500;
    font-size: 18px; /* Adjust the font size according to your design preferences */
  }

  .help-close-btn {
    background: transparent;
    border: none;
    color: white;
    padding: 0;
    margin: 0;
    max-width: 30px;
    align: right;
    font-weight: bold;
    font-size: 16px;
    cursor: pointer;
  }

  .help-popup-content {
    padding: 20px;
    overflow-y: auto;
    font-family: "Roboto", sans-serif;
  }

</style>

<div id="help-popup" class="help-popup hidden">
  <div class="help-popup-header">
    <h3>Help</h3>
    <button class="help-close-btn" onclick="closeHelpPopup()">
      <i class="fas fa-window-close"></i>
    </button>
  </div>

  <div class="help-popup-content">
    Creating a new map and setting the map name:
    <ul>
      <li> Change the URL to file://<path>/simbiotica.html?map=[map_name] </li>
      <li> This format was chosen for easy bookmarking in your web browser </li>
    </ul>
    Security:
    <ul>
      <li> The security of your OpenAI API key is important. Efforts have been made with this app to ensure its safety.</li>
      <li> This code is open source and not minified, making it easily reviewable.</li>
      <li> Your API key is not stored locally in any persistent storage and must be entered each time you load this page.</li>
      <li> All imports have SRI hashes, and external code has been reviewed for potential issues.</li>
      <li> This app is fairly lightweight in its usage, but make sure you have a spending limit on your OpenAI account. You can see token count usage in the settings page.</li>
    </ul>
    Interacting with the mindmap:
    <ul>
      <li> Mouse click to select a node, double-click to edit, press Enter to save </li>
      <li> You can either click and drag your mouse to pan the mindmap, or use mousewheel / two-finger guestures on touchpad to scroll the mindmap vertically or horizontally if it's larger in those dimensions (respectively) to the screen. </li>
      <li> Mouse drag nodes to move to another node</li>
      <li> Mouse click small circle to expand/collapse</li>
      <li> Press Enter to create a sibling node</li>
      <li> Press Ctrl-Enter to create a child node</li>
      <li> Press Delete to delete a node</li>
    </ul>
    Note that maps are autosaved via the IndexedDB API, browser-based storage that is only accessible by the same origin. In other words, your maps can only be accessed from where this page is being served from. Be careful when using other browser-based applications you save/serve from the same location, as they can access the IndexDB API storage. Use only code that is openly reviewable, open source, or from a trusted entity.
    <br />
    <br />
    Button bar:
    <ul>
      <li> <i class="fas fa-download"></i> - Make a backup of the map. As mentioned above, the map is already stored in your browser, but this can be used for transferring between computers.</li>
      <li> <i class="fas fa-upload"></i> - Load a backup of the map. The map must be empty to ensure you don't accidentally overwrite another map.</li>
      <li> <i class="fas fa-share-alt"></i> - Get suggestions from GPT-3.5, which is what this is all about!  You can configure how this is done in settings.</li>
      <li> <i class="fas fa-compress-alt"></i> - Collapse all</li>
      <li> <i class="fas fa-expand-alt"></i> - Expand all</li>
      <li> <i class="fas fa-search-plus"></i> - Zoom in</li>      
      <li> <i class="fas fa-search-minus"></i> - Zoom out</li>
      <li> <i class="fas fa-comments"></i> - Engage in a deeper discussion with GPT-3.5 about a particular node.  The first time you chat about a node both the mindmap and a series of questions will be sent to GPT API.  Subsequently, all messages will be prefixed with the mindmap only.  You can configure these prompts in settings.</li>
      <li> <i class="fas fa-rotate-left"></i> - Undo, may have to click twice.  This is a bit hard to use right now, working on it.</li>
      <li> <i class="fas fa-rotate-right"></i> - Redo, may have to click twice</li>
      <li> <i class="fas fa-gear"></i> - Settings. You can change the prompts used to get suggestions and discuss nodes. Make sure you review them carefully before making changes. Backing up a copy of the prompt for reverting is probably a good idea.</li>
    </ul>
      </div>
  </div>
    </ul>
    
  </div>
</div>

<script type="text/javascript">
  setupPopSizeListener(750, 600, document.getElementById("help-popup"));
  
  function openHelpPopup() {
    document.getElementById("help-popup").classList.remove("hidden");
  }

  function closeHelpPopup() {
    document.getElementById("help-popup").classList.add("hidden");
  }

</script>

    <style>
  #main_container {
    width: 200px;
    position: relative;
    z-index: 2;
  }

  #jsmind_container {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: #000000;
    z-index: 1;
  }

  #jsmind_nav ul {
    padding: 0;
  }

  #jsmind_nav li {
    margin-right: 10px;
  }

  #jsmind_nav button {
    background-color: transparent;
    border: none;
    color: #fff;
    cursor: pointer;
    font-size: 24px;
    padding: 5px;
  }

  #jsmind_nav button:hover {
    color: #007bff;
  }

  #jsmind_nav label {
    cursor: pointer;
    font-size: 18px;
    padding: 5px;
    color: #333;
  }

  #jsmind_nav label:hover {
    color: #007bff;
  }

  .draggable {
      position: fixed;
      bottom: 0;
      
      margin-bottom: 2px;
      margin-left: 4px;
      background: #34495e;
      border-radius: 5px;
      box-shadow: 3px 4px 6px rgba(128, 128, 128, 0.5);
      display: flex;
      justify-content: space-around;
      align-items: center;
      padding: 5px;
      cursor: move;
      min-width: 600px;
  }

  .icon-button {
      background: none;
      border: none;
      cursor: pointer;
      font-size: 24px;
  }

  .icon-button:hover {
      color: #007bff;
  }
  
  body jmnode {
      font: 12px/1.125 Verdana, Arial, Helvetica, sans-serif;
      padding: 5px;
  }
  
</style>
<div id="jsmind_container"></div>
<div id="main_container">
  <div id="jsmind_nav">
    <div id="button-bar" class="draggable">
              <button  class="icon-button"  onclick="save_file();" title="Save File">
          <i class="fas fa-download"></i>
              </button>
	      
              <input
          id="file_input"
          class="file_input"
          type="file"
          style="display: none"
        /><label for="file_input" title="Upload File"
          ><i
            style="color: #fff; margin-right: 20px; margin-top: 2px; font-size: 24px"
            class="fas fa-upload"
          ></i
        ></label>
      
        <button class="icon-button" onclick="add_node();" id="add-node-button" title="Add Node">
          <i class="fas fa-share-alt"></i>
        </button>
      
        <button  class="icon-button"  onclick="collapse_all();" title="Collapse All">
          <i class="fas fa-compress-alt"></i>
        </button>
      
        <button  class="icon-button"  onclick="expand_all();" title="Expand All">
          <i class="fas fa-expand-alt"></i>
        </button>
      
        <button   class="icon-button"  id="zoom-in-button" onclick="zoomIn();" title="Zoom In">
          <i class="fas fa-search-plus"></i>
        </button>
      
        <button  class="icon-button" id="zoom-out-button" onclick="zoomOut();" title="Zoom Out">
          <i class="fas fa-search-minus"></i>
        </button>
            
        <button  class="icon-button" onclick="discuss_node()" title="Open Chat">
          <i class="fas fa-comments"></i>
        </button>
      
<!--        <button  class="icon-button" onclick="restructure()" title="Restructure">
          <i class="fas fa-random"></i>
        </button>-->
      
        <button  class="icon-button" onclick="undo()" title="Undo">
          <i class="fas fa-rotate-left"></i>
        </button>
      
        <button  class="icon-button" onclick="redo()" title="Redo">
          <i class="fas fa-rotate-right"></i>
        </button>
      
        <button  class="icon-button" onclick="openSettingsPopup()" title="Settings">
          <i class="fas fa-gear"></i>
        </button>
        <button  class="icon-button" onclick="openHelpPopup()" title="Help">
          <i class="fas fa-info-circle"></i>
        </button>
        </div>
  <div style="display: none">
    <input class="file" type="file" id="image-chooser" accept="image/*" />
  </div>
</div>

<script type="text/javascript">

  function patch_jm(_jm) {
      _jm.layout._layout_offset_subnodes = function(nodes) {
	  var total_height = 0;
	  var nodes_count = nodes.length;
	  var i = nodes_count;
	  var node = null;
	  var node_outer_height = 0;
	  var layout_data = null;
	  var base_y = 0;
	  var pd = null; // parent._data
	  while (i--) {
	      node = nodes[i];
	      layout_data = node._data.layout;
	      if (pd == null) {
		  pd = node.parent._data;
	      }

	      node_outer_height = this._layout_offset_subnodes(node.children);
	      if (!node.expanded) {
		  node_outer_height = 0;
		  this.set_visible(node.children, false);
	      }
	      node_outer_height = Math.max(node._data.view.height, node_outer_height);

	      layout_data.outer_height = node_outer_height;
	      layout_data.offset_y = base_y - node_outer_height / 2;
	      layout_data.offset_x =
		  this.opts.hspace * layout_data.direction +
		  (pd.view.width * (pd.layout.direction + layout_data.direction)) / 2;
	      if (!node.parent.isroot) {
		  layout_data.offset_x += this.opts.pspace * layout_data.direction;
	      }

	      base_y = base_y - node_outer_height - this.opts.vspace;
	      total_height += node_outer_height;
	  }
	  if (nodes_count > 1) {
	      total_height += this.opts.vspace * (nodes_count - 1);
	  }
	  i = nodes_count;
	  var middle_height = total_height / 2;
	  while (i--) {
	      node = nodes[i];
	      node._data.layout.offset_y += middle_height;
  }
	  return total_height+10;
      }

      _jm.layout._layout_offset_subnodes_height = function(nodes) {
      var total_height = 0;
      var nodes_count = nodes.length;
      var i = nodes_count;
      var node = null;
      var node_outer_height = 0;
      var layout_data = null;
      var base_y = 0;
      var pd = null; // parent._data
      while (i--) {
	  node = nodes[i];
	  layout_data = node._data.layout;
	  if (pd == null) {
	      pd = node.parent._data;
	  }

	  node_outer_height = this._layout_offset_subnodes_height(node.children);
	  if (!node.expanded) {
	      node_outer_height = 0;
	  }
	  node_outer_height = Math.max(node._data.view.height, node_outer_height);

	  layout_data.outer_height = node_outer_height;
	  layout_data.offset_y = base_y - node_outer_height / 2;
	  base_y = base_y - node_outer_height - this.opts.vspace;
	  total_height += node_outer_height;
      }
      if (nodes_count > 1) {
	  total_height += this.opts.vspace * (nodes_count - 1);
      }
      i = nodes_count;
      var middle_height = total_height / 2;
      while (i--) {
	  node = nodes[i];
	  node._data.layout.offset_y += middle_height;
      }
      console.log("layout", total_height);
      return total_height+10;
  }
  }
  const buttonBar = document.getElementById('button-bar');

  buttonBar.addEventListener('mousedown', (event) => {
      const offsetX = event.clientX - buttonBar.getBoundingClientRect().left;
      const offsetY = buttonBar.getBoundingClientRect().bottom;
      const onMouseMove = (event) => {
	  buttonBar.style.left = `${event.clientX - offsetX}px`;
	  buttonBar.style.bottom = `${offsetY - event.clientY}px`;
      };

      const onMouseUp = () => {
	  document.removeEventListener('mousemove', onMouseMove);
	  document.removeEventListener('mouseup', onMouseUp);
      };

      document.addEventListener('mousemove', onMouseMove);
      document.addEventListener('mouseup', onMouseUp);
  });
  
  
  function showSpinner() {
    const button = document.getElementById("add-node-button");
    button.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
  }

  function hideSpinner() {
    const button = document.getElementById("add-node-button");
    button.innerHTML = '<i class="fas fa-share-alt"></i>';
  }

  function getParameterFromUrl(paramName) {
    try {
      const urlSearchParams = new URLSearchParams(window.location.search);
      return urlSearchParams.get(paramName);
    } catch (error) {
      return null;
    }
  }

  let dbName = getParameterFromUrl("map");
  if (dbName == null) {
    dbName = "default";
  }

  async function openDatabase(dbName) {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(dbName, 1);

      request.onupgradeneeded = (event) => {
        const db = event.target.result;
        db.createObjectStore("dataStore", { keyPath: "id" });
      };

      request.onsuccess = (event) => {
        resolve(event.target.result);
      };

      request.onerror = (event) => {
        reject(event.target.error);
      };
    });
  }

  async function loadData(dbName, defaultValue) {
    try {
      const db = await openDatabase(dbName);
      return new Promise((resolve, reject) => {
        const transaction = db.transaction(["dataStore"], "readonly");
        const objectStore = transaction.objectStore("dataStore");
        const request = objectStore.get(1);

        request.onsuccess = (event) => {
          const data = event.target.result;
          resolve(data ? data.value : defaultValue);
        };

        request.onerror = (event) => {
          reject(event.target.error);
        };
      });
    } catch (error) {
      console.error("Error loading data:", error);
    }
  }

  async function saveData(dbName, data) {
    try {
      const db = await openDatabase(dbName);
      return new Promise((resolve, reject) => {
        const transaction = db.transaction(["dataStore"], "readwrite");
        const objectStore = transaction.objectStore("dataStore");
        const request = objectStore.put({ id: 1, value: data });

        request.onsuccess = (event) => {
          resolve();
        };

        request.onerror = (event) => {
          reject(event.target.error);
        };
      });
    } catch (error) {
      console.error("Error saving data:", error);
    }
  }

  var redo_manager_disabled = false;
  
  async function autoSaveData() {
      var data = _jm.get_data();
      if (!redo_manager_disabled) {
	  console.log("autoSaveData performAction");
	  undoRedoManager.performAction(data);
      }
    document.title = data.data.topic;
    recordSettings(data);
    await saveData(dbName, data);
  }

  function undo() {
      const repeat = undoRedoManager.undo(_jm.get_data());
      console.log(repeat);
      if (repeat != null) {
	  _jm.show(repeat);
      }
  }
  
  function redo() {
      const repeat = undoRedoManager.redo();
      if (repeat != null) {
	  _jm.show(repeat);
      }
  }
  
  var _jm = null;

  function get_def_options() {
    var def_options = {
      container: "jsmind_container",
      theme: "asphalt",
      editable: true,
      support_html: false,
      view: {
        node_overflow: "wrap",
        engine: "svg",
          draggable: true,
	    line_width:3, 
      },

	layout: {
	    hspace: 40,
	    vspace: 10,
	    pspace: 20,
	},
    };
      return def_options;
  }

  function get_def_mind() {
    var mind = {
      meta: {
        name: "Simbiotico",
        author: "http://twitter.com/QRDL",
        version: "0.1",
      },

      format: "node_tree",
      data: {
        id: "root",
        topic: "Simbiotico",
      },
    };
      return mind;
  }

  function init_jm(def_options, options) {
      def_options.view.line_width = 3;
      _jm = new jsMind(def_options);
      patch_jm(_jm);
      console.log("open_empty 1", _jm.options);
      _jm.show(options);
      console.log("open_empty 2", _jm.options);
      
    load_meta_properties(options);
    _jm.add_event_listener(async function (type, data) {
      if (
        ["update_node", "expand_node", "collapse_node", "remove_node"].includes(
          data.evt
        )
      ) {
        await autoSaveData();
      } else {
          console.log("event", data);
      }
    });
      return _jm;
  }
  
  async function open_empty() {
      const def_options = get_def_options();
      const mind = get_def_mind();
      const options = await loadData(dbName, mind);
      console.log("open_empty performAction");
    undoRedoManager.performAction(options);
      _jm = init_jm(def_options, options);
  }

  function save_file() {
    var mind_data = _jm.get_data();
    var mind_name = mind_data.meta.name;
    var mind_str = jsMind.util.json.json2string(mind_data);
    jsMind.util.file.save(mind_str, "text/jsmind", mind_name + ".jm");
  }

  function open_file(event) {
    var files = document.getElementById("file_input").files;
    console.log(files);
    if (
      _jm.get_data().data.children &&
      _jm.get_data().data.children.length > 0
    ) {
      prompt_info(
        "Please start with an empty mindmap before loading from disk."
      );
      event.target.value = null;
      return;
    }
    if (files.length > 0) {
      var file_data = files[0];
      jsMind.util.file.read(file_data, function (jsmind_data, jsmind_name) {
        var mind = jsMind.util.json.string2json(jsmind_data);
        if (!!mind) {
          _jm.show(mind);
          load_meta_properties(mind);
        } else {
          prompt_info("can not open this file as mindmap");
        }
      });
    } else {
      prompt_info("please choose a file first");
    }
    event.target.value = null;
  }

  document.getElementById("file_input").addEventListener("change", open_file);

  function get_selected_nodeid() {
    var selected_node = _jm.get_selected_node();
    if (!!selected_node) {
      return selected_node.id;
    } else {
      return null;
    }
  }

  function createHyphenatedList(node, depth = 0) {
    let result = "";
    let prefix = " ".repeat(depth * 2);
    result += `${prefix}- ${node.topic}\n`;
    if (!node.expanded) return result;

    if (node.children) {
      for (const child of node.children) {
        result += createHyphenatedList(child, depth + 1);
      }
    }

    return result;
  }

  const API_URL = "https://api.openai.com/v1/chat/completions";

  async function chatGPTRequest(prompt, curNode = null) {
      try {

	  gptEngine = document.getElementById("gpt-engine").value;
	  maxTokens = 4096;//document.getElementById("max-tokens").value;
	  temperature = parseFloat(document.getElementById("temperature").value);
	  if (isNaN(temperature)){
	      temperature = 0.3;
	  }
      const response = await fetch(API_URL, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${API_KEY}`,
        },
        body: JSON.stringify({
            model: gptEngine,
          messages: [{ role: "user", content: prompt }],
          temperature: temperature,
        }),
      });
	  if (!response.ok) {
	      console.log(response);
	      prompt_info("Error communication with OpenAI API:"+response.status+" 401 means that your API Key is incorrect.");
	      throw new Error(`HTTP error: ${response.status}`);
	  }
	  
	const data = await response.json();
	console.log("chatGPTRequest", data);
	addTokenUsage(data.usage.total_tokens);
      const resp = data.choices[0].message.content;
      if (curNode) {
        dict = curNode.data;
        if (!dict.hasOwnProperty("chatlog")) {
          dict["chatlog"] = "";
        }
	  
        dict["chatlog"] += "user-message:\n" + prompt + "\n";
        dict["chatlog"] += "gpt-message:\n" + resp + "\n\n";
        _jm.set_node_color(curNode.id, "#FFA533", null);
        await autoSaveData();
      }

      return resp;
    } catch (error) {
      console.error("Error:", error);
    }
  }

  function secureEvaluateTemplate(template, context) {
    return template.replace(/\$\{(\w+)\}/g, (_, variable) => {
      return context[variable] || "";
    });
  }

  async function get_children_suggestions(node, _jm, tmpl) {
    const text_of_node = node.topic;
    const hyphenated_list = createHyphenatedList(_jm.get_data().data);
      var prompt = tmpl;
    prompt = secureEvaluateTemplate(prompt, {
      hyphenated_list: hyphenated_list,
      text_of_node: text_of_node,
    });
    console.log(prompt);
      // Make sure you call the chatGPTRequest function with the prompt
    showSpinner();
    const data = await chatGPTRequest(prompt);
    hideSpinner();
    return data;
  }

  function processGptResponse(response, selected_node, _jm, do_scroll = true) {
    // Step 1: Extract content between <embed> tags
    const embedContent = response.match(/<embed>([\s\S]*?)<\/embed>/)[1].trim();

    // Step 2: Process the extracted content and build the hierarchy
    const lines = embedContent.split("\n");
    const hierarchy = [];

    for (const line of lines) {
      const level = line.search(/\S/);
      const content = line.trim().replace(/^-/, "").trim();

      hierarchy.push({
        level: level / 2,
        content: content,
        id: jsMind.util.uuid.newid(),
      });
    }

    console.log(hierarchy);
    // Step 3: Add nodes to jsMind with the correct connections
    for (let i = 0; i < hierarchy.length; i++) {
      const currentNode = hierarchy[i];
      let parentId = selected_node;

      if (currentNode.level > 0) {
        for (let j = i - 1; j >= 0; j--) {
          if (hierarchy[j].level === currentNode.level - 1) {
            parentId = hierarchy[j].id;
            break;
          }
        }
      }

	nd = _jm.add_node(parentId, currentNode.id, currentNode.content);
	console.log(nd);
	if (do_scroll) {
	    nd._data.view.element.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: "nearest"  });
	}
    }
  }

  async function add_node() {
    var selected_node = _jm.get_selected_node(); // as parent of new node
    if (!selected_node) {
      prompt_info("please select a node first.");
      return;
    }

    // Call get_children_suggestions function and wait for the response
      const response = await get_children_suggestions(selected_node, _jm, document.getElementById("child-node-suggestion").value);
    console.log(response);
      // Call processGptResponse function to process the response and add nodes
      console.log("add_node redo_manager true");
      redo_manager_disabled = true;
      processGptResponse(response, selected_node, _jm);
      console.log("add_node redo_manager false");
      setTimeout(async () => {
	  redo_manager_disabled = false;
	  await autoSaveData();
      }, 1000);
  }

  async function restructure() {
      var selected_node = _jm.get_root();
      const response = await get_children_suggestions(selected_node, _jm, document.getElementById("restructure-prompt").value);
      const def_options = get_def_options();
      const mind = get_def_mind();
      _jm = init_jm(def_options, mind);
      var selected_node = _jm.get_root();


      console.log(response);
    
      processGptResponse(response, selected_node, _jm);

  }



  var zoomInButton = document.getElementById("zoom-in-button");
  var zoomOutButton = document.getElementById("zoom-out-button");

  function zoomIn() {
    if (_jm.view.zoomIn()) {
      zoomOutButton.disabled = false;
    } else {
      zoomInButton.disabled = true;
    }
  }

  function zoomOut() {
    if (_jm.view.zoomOut()) {
      zoomInButton.disabled = false;
    } else {
      zoomOutButton.disabled = true;
    }
  }

  function expand_all() {
    _jm.expand_all();
  }

  function collapse_all() {
    _jm.collapse_all();
  }

  function prompt_info(msg) {
    showCustomAlert(msg);
  }

  open_empty();
</script>

    <style>
  .hidden {
    display: none;
  }

  .custom-alert {
    position: fixed;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.5);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 20000;
  }

  .custom-alert-content {
    background-color: white;
    padding: 20px;
    border-radius: 5px;
    text-align: center;
  }

  .custom-alert-message {
    display: block;
    margin-bottom: 20px;
  }

  .custom-alert-close {
    background-color: #0066ff;
    color: white;
    border: none;
    border-radius: 3px;
    padding: 8px 16px;
    cursor: pointer;
    font-weight: bold;
  }
</style>

<div id="custom-alert" class="custom-alert hidden">
  <div class="custom-alert-content">
    <span id = "custom-alert-message" class="custom-alert-message"></span>
    <button class="custom-alert-close" onclick="closeCustomAlert()">OK</button>
  </div>
</div>

<script type="text/javascript">
  function showCustomAlert(message) {
    const customAlert = document.getElementById("custom-alert");
    const customAlertMessage = document.getElementById("custom-alert-message");
    customAlertMessage.textContent = message;
    customAlert.classList.remove("hidden");
  }

  function closeCustomAlert() {
    const customAlert = document.getElementById("custom-alert");
    customAlert.classList.add("hidden");
  }
</script>

    <!-- logindiv -->
<style>
  .modal {
    display: none;
    position: fixed;
    z-index: 10000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    overflow: auto;
    background-color: rgba(0, 0, 0, 0.4);
  }

  .modal-content {
    background-color: #fefefe;
    margin: 15% auto;
    padding: 20px;
    border: 1px solid #888;
    width: 80%;
    text-align: center;
  }

  input[type="text"] {
    width: 100%;
    padding: 12px 20px;
    margin: 8px 0;
    display: inline-block;
    border: 1px solid #ccc;
    box-sizing: border-box;
  }

  button {
    background-color: #4caf50;
    color: white;
    padding: 14px 20px;
    margin: 8px 0;
    border: none;
    cursor: pointer;
    width: 100%;
  }

  button:hover {
    opacity: 0.8;
  }
</style>
<div id="api-key-modal" class="modal">
  <div class="modal-content">
    <h2>Enter GPT API Key</h2>
    <p>Please enter your API key to continue.  This is a browser side application only, no server except for OpenAI.<br/>
      The key is not persisted in browser storage and only used when sending to OpenAI REST api. <br />
      Token usage is relatively light and you can find a total usage count via settings (gear) icon. <br />
      The source code is not minified and should be easily reviewable via developer tools, your filesystem, and/or the github repo.<br />
      Make sure to follow <a href=http://twitter.com/QRDL>http://twitter.com/QRDL</a> for information and updates.<br />
    <input type="text" id="api-key-input" style="-webkit-text-security: disc;">
    <button id="submit-api-key">Submit</button>
  </div>
</div>

<script type="text/javascript">
  let API_KEY = "";

  document.addEventListener("DOMContentLoaded", function () {
    const apiKeyModal = document.getElementById("api-key-modal");
    const submitApiKeyButton = document.getElementById("submit-api-key");

    function showApiKeyModal() {
      apiKeyModal.style.display = "block";
    }

      function hideApiKeyModal() {
      document.getElementById("api-key-input").value = "";
      apiKeyModal.style.display = "none";
    }

    submitApiKeyButton.addEventListener("click", () => {
      const apiKeyInput = document.getElementById("api-key-input");
      API_KEY = apiKeyInput.value.trim();  //This is the only place we 'store' the key
      const apiKey = API_KEY;
      if (apiKey) {
        hideApiKeyModal();
      } else {
        showCustomAlert("Please enter a valid API key.");
      }
    });

    // Show the modal dialog on page load.
    showApiKeyModal();
  });
</script>

    <style>
  .popup {
    position: fixed;
    top: 60px;
    right: 60px;
    width: 600px;
    height: 750px;
    background: white;
    border: 1px solid #ccc;
    border-radius: 5px;
    display: flex;
    flex-direction: column;
    z-index: 1000;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
  }

  .popup-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 5px;
    background: #0066ff;
    color: white;
    font-weight: bold;
    border-top-left-radius: 5px;
    border-top-right-radius: 5px;
    font-family: "Roboto", sans-serif;
  }

  .popup-header h3 {
    margin: 0;
    font-family: "Roboto", sans-serif;
    font-weight: 500;
    font-size: 18px; /* Adjust the font size according to your design preferences */
  }

  .close-btn {
    background: transparent;
    border: none;
    color: white;
    font-weight: bold;
    font-size: 16px;
    cursor: pointer;
  }

  .popup-content {
    padding: 20px;
    overflow-y: auto;
  }

  .form-group {
    display: flex;
    flex-direction: column;
    margin-bottom: 20px;
  }

  label {
    margin-bottom: 5px;
    font-family: "Roboto", sans-serif;
  }

  textarea,
  input {
    padding: 8px;
    border: 1px solid #ccc;
    border-radius: 4px;
    resize: vertical;
  }

  .save-btn {
    background: #0066ff;
    color: white;
    border: none;
    border-radius: 4px;
    padding: 8px 16px;
    font-weight: bold;
    cursor: pointer;
    align-self: flex-end;
  }
</style>

<!-- settingsdiv -->
<div id="settings-popup" class="popup hidden">
  <div class="popup-header">
    <h3>Settings</h3>
    <button class="close-btn" onclick="closeSettingsPopup()">
      <i class="fas fa-window-close"></i>
    </button>
  </div>
  <div class="popup-content">
    <form id="settings-form">
      <div class="form-group">
        <label for="token-usage">Token Usage for this map:</label>
        <label
          id="token-usage"
        ></label>
      </div>
      <div class="form-group">
        <label for="child-node-suggestion">Child Node Suggestion Prompt:</label>
        <textarea
          id="child-node-suggestion"
          rows="8"
          placeholder="Enter child node suggestion prompt."
        ></textarea>
      </div>
      <div class="form-group">
        <label for="discuss-node-prompt">Discuss Node Prompt:</label>
        <textarea
          id="discuss-node-prompt"
          rows="18"
          placeholder="Enter discuss node prompt"
        ></textarea>
      </div>
      <div class="form-group">
        <label for="prefix-prompt">Discuss Prompt Prefix:</label>
        <textarea
          id="prefix-prompt"
          rows="5"
          placeholder="Enter prompt prefix"
        ></textarea>
      </div>
<!--      <div class="form-group">
        <label for="prefix-prompt">Restructure Prompt:</label>
        <textarea
          id="restructure-prompt"
          rows="5"
          placeholder="Enter restructure"
        ></textarea>
      </div>-->
      <div class="form-group">
        <label for="gpt-engine">GPT Engine:</label>
        <input id="gpt-engine" type="text" placeholder="Enter GPT engine" />
      </div>
	    
      <div class="form-group">
        <label for="temperature">Temperature:</label>
        <input id="temperature" type="text" placeholder="Enter temperature" />
      </div>
	    
      <div class="form-group">
        <label for="theme">Theme:</label>
      <select onchange="set_theme(this.value);">
          <option value="">default</option>
          <option value="primary">primary</option>
          <option value="warning">warning</option>
          <option value="danger">danger</option>
          <option value="success">success</option>
          <option value="info">info</option>
          <option value="greensea" selected="selected">greensea</option>
          <option value="nephrite">nephrite</option>
          <option value="belizehole">belizehole</option>
          <option value="wisteria">wisteria</option>
          <option value="asphalt">asphalt</option>
          <option value="orange">orange</option>
          <option value="pumpkin">pumpkin</option>
          <option value="pomegranate">pomegranate</option>
          <option value="clouds">clouds</option>
          <option value="asbestos">asbestos</option>
        </select>
      </div>
    </form>
  </div>
</div>

<script type="text/javascript">
  setupPopSizeListener(750, 600, document.getElementById("settings-popup"));
  
  function set_theme(theme_name) {
    _jm.set_theme(theme_name);
  }


  function getValueOrDefault(obj, key, defaultValue) {
    if (!obj.hasOwnProperty(key)) {
      return defaultValue;
    }
    return obj[key];
  }

  function openSettingsPopup() {
    document.getElementById("settings-popup").classList.remove("hidden");
  }

  function closeSettingsPopup() {
    console.log("close");
    document.getElementById("settings-popup").classList.add("hidden");
    autoSaveData();
  }
  function recordSettings(data) {
    console.log(data);
    // Get the values from the form fields
    data["child-node-suggestion"] = document.getElementById(
      "child-node-suggestion"
    ).value;
    data["discuss-node-prompt"] = document.getElementById(
      "discuss-node-prompt"
    ).value;
    data["prefix-prompt"] = document.getElementById("prefix-prompt").value;
    //data["restructure-prompt"] = document.getElementById("restructure-prompt").value;
    data["gpt-engine"] = document.getElementById("gpt-engine").value;
    data["token-usage"] = document.getElementById("token-usage").textContent;
    data["temperature"] = document.getElementById("temperature").value;
    console.log("recordSettings", data);
  }

  function addTokenUsage(tokens) {
      value = document.getElementById("token-usage").textContent;
      if (value == "" || isNaN(parseInt(value))) {
	  count = 0;
      } else {
	  count = parseInt(value);
      }
      console.log("addTokenUsage", value, count, tokens, count+tokens);
      document.getElementById("token-usage").textContent = (count + tokens).toString();
  }
  
  function saveSettings(event) {
    if (event) event.preventDefault();
    closeSettingsPopup();
  }

  // Attach the event listener to the form
  document
    .getElementById("settings-form")
    .addEventListener("submit", saveSettings);

  function load_meta_properties(options) {
    document.getElementById("token-usage").textContent = getValueOrDefault(
	options, "token-usage", (0).toString())
    document.getElementById("discuss-node-prompt").value = getValueOrDefault(
      options,
      "discuss-node-prompt",
      "I am creating a mindmap.  Here is what's currently visible in the mindmap:\n" +
        "${hyphenated_list}\n" +
        "I'd like to discuss with you about the '${text_of_node}' node.\n" +
        "Respond with your thoughts on:\n" +
        "1. What this node means, both specifically and generally\n" +
        "2. The relevance of this node, how it contributes individually and holistically\n" +
        "3. Where it fits in the mindmap (see the indented listed above)\n" +
        "4. What are some things to consider when adding children, sibling, and parent nodes around it in the mindmap\n" +
        "5. What are some good questions to ask ChatGPT to get a better understanding of this node?\n" +
        "6. And finally, just some novel creative ideas to think about in relation to this node.\n" +
        "When addressing these points, please remember we're talking about the ${text_of_node}' node within the context of the hyphenated mindmap list above."
    );

    document.getElementById("child-node-suggestion").value = getValueOrDefault(
      options,
      "child-node-suggestion",
      "I am creating a mindmap.  Here is what's currently visible:\n" +
        "${hyphenated_list}\n" +
        "I need some ideas for adding at least two child nodes to '${text_of_node}'.\n" +
        "Provide a list of suggestions, in the same hyphenated format above, that would be ideal children of '${text_of_node}', with no empty lines. The list should be prioritized by relevance and importance.\n" +
        "Surround the list of suggestions with <embed></embed>\n" +
        "Do not make suggestions which are redundant to ones already listed above.\n" +
        "Do not repeat ${text_of_node}' in the list.\n"+
	"There must be at least two suggestions for the immediate child nodes of '${text_of_node}'.\n"+
	"Each suggestion must complement, augment, and harmonize with the mindmap listed above.\n"
    );
    document.getElementById("prefix-prompt").value = getValueOrDefault(
      options,
      "prefix-prompt",
      "I am creating a mindmap, here's what's currently visible in the mindmap:\n${hyphenated_list}\nI would like to discuss the '${cur_topic}' node.\n\n"
    );

   /* document.getElementById("restructure-prompt").value = getValueOrDefault(
      options,
      "restructure-prompt",
	"I am creating a mindmap, here's what is currently visible in the mindmap:\n${hyphenated_list}\n"+
	"Restructure the mindmap listed above into a more cohesive, clear, and impactful mindmap.\n"+
	    "The restructured mindmap should have many levels, but no less than 3 children and no more than 6 children per item.\n"+
	    "Use the same hyphenated hierarchical format above, with no empty lines.\n"+
	    "Ensure that the hierarchical hyphenated list is surrounded by <embed></embed>.\n"+
	    "Do not include the top level node.\n"
    );*/

    document.getElementById("gpt-engine").value = getValueOrDefault(
      options,
      "gpt-engine",
      "gpt-3.5-turbo"
    );
    document.getElementById("temperature").value = getValueOrDefault(
      options,
      "temperature",
      "0.7"
    );
  }
</script>

    <style>
  .chat-popup {
    position: fixed;
    bottom: 60px;
    right: 60px;
    width: 600px;
    height: 800px;
    background: white;
    border: 1px solid #ccc;
    border-radius: 5px;
    display: flex;
    flex-direction: column;
    z-index: 1000;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
  }

  .chat-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 5px;
    background: #0066ff;
    color: white;
    font-weight: bold;
    border-top-left-radius: 5px;
    border-top-right-radius: 5px;
  }

  .chat-header h3 {
    margin: 0;
    font-family: "Roboto", sans-serif;
    font-weight: 500;
    font-size: 18px; /* Adjust the font size according to your design preferences */
  }

  .close-btn {
    background: transparent;
    border: none;
    color: white;
    font-weight: bold;
    font-size: 16px;
    cursor: pointer;
    position: absolute;
    top: 5px;
    right: 5px;
    padding: 0;
    margin: 0;
    width: 20px;
  }

  .chat-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .chat-content {
    flex: 1;
    padding: 5px;
    overflow-y: auto;
    background-color: #f9f9f9;
  }

  .chat-messages * {
    display: flex;
    flex-direction: column;
    overflow-anchor: none;
  }
  .anchor {
    overflow-anchor: auto;
    height: 1px;
  }

  .chat-input {
    display: flex;
    padding: 5px;
    border-top: 1px solid #ccc;
  }

  .chat-input input {
    flex: 1;
    margin-right: 5px;
    resize: none;
    overflow: auto;
    height: 60px;
    border-radius: 4px;
    border: 1px solid #ccc;
    padding: 0 5px;
  }

  .chat-input button {
    border: none;
    background-color: #0066ff;
    color: white;
    padding: 5px 10px;
    font-weight: bold;
    border-radius: 4px;
    cursor: pointer;
  }

  .chat-input button:hover {
    background-color: #0051cc;
  }

  .backlog-message,
  .user-message,
  .gpt-message {
    font-family: Arial, sans-serif;
    font-size: 14px;
    margin-bottom: 5px;
    line-height: 1.4;
  }

  .backlog-message {
    font-family: Courier, monospace;
    font-size: 14px;
    color: #71797e;
    margin-bottom: 5px;
    margin-left: 10px;
    white-space: pre-wrap;
  }

  .user-message {
    font-family: Courier, monospace;
    font-size: 14px;
    color: #1a1a1a;
    margin-bottom: 5px;
    margin-left: 10px;
    white-space: pre-wrap;
  }

  .gpt-message {
    color: #666;
    margin-left: 20px;
  }

  .resize-handle {
    width: 100%;
    height: 15px;
    cursor: nwse-resize;
    background: #f4f4f4;
    border-top: 1px solid #ccc;
    display: flex;
    justify-content: right;
    align-items: right;
    font-size: 12px;
    user-select: none;
  }

  .resize-handle i {
    color: #71797e;
    font-size: 16px;
    transform: rotate(45deg);
    margin: 0 4px 4px 0; /* Adjust these values to position the icon correctly */
  }

  .resize-indicator {
    width: 70%;
    height: 1px;
    background-color: #ccc;
    border-radius: 1px;
  }

  .hidden {
    display: none !important;
  }

  .send-button {
      width: 100px;
  }
  .chat-input textarea {
    flex: 1;
    margin-right: 5px;
    resize: none;
    overflow: auto;
    height: 40px;
    border-radius: 4px;
    border: 1px solid #ccc;
    padding: 5px;
  }
</style>

<div id="chat-popup" class="chat-popup hidden">
  <div class="chat-header">
    <h3>Chat with GPT</h3>
    <button class="close-btn" onclick="closeChatPopup()">
      <i class="fas fa-window-close"></i>
    </button>
  </div>
  <div class="chat-content">
    <div class="chat-messages" id="chat-messages"></div>
    <div id="anchor"></div>
  </div>
  <div class="chat-input">
    <textarea
      id="chat-input-text"
      rows="3"
      placeholder="Type your prompt, note the hierarchical list above will be prefixed to your message so you may refer to it in your prompt."
    ></textarea>
    <button class="send-button" onclick="submitChatMessage()">Send</button>
  </div>
  <div class="resize-handle"><i class="fas fa-arrows-alt"></i></div>
</div>

<script>


  setupPopSizeListener(800, 600, document.getElementById("chat-popup"));
  
  function get_node_discussion_prompt(node, _jm) {
    const text_of_node = node.topic;
    const hyphenated_list = createHyphenatedList(_jm.get_data().data);
    var prompt = document.getElementById("discuss-node-prompt").value;
    prompt = secureEvaluateTemplate(prompt, {
      hyphenated_list: hyphenated_list,
      text_of_node: text_of_node,
    });
    console.log(prompt);
    return prompt;
  }

  function scrollToBottom() {
    var anchor = document.getElementById("anchor");
    anchor.scrollIntoView({ behavior: "smooth", block: "end" });
  }

  function observeChatMessages() {
    const chatMessages = document.getElementById("chat-messages");
    const observer = new MutationObserver(scrollToBottom);

    observer.observe(chatMessages, {
      childList: true, // Observe changes to the children of chatMessages
      subtree: true, // Observe changes to the descendants of chatMessages
    });
  }

  document.addEventListener("DOMContentLoaded", function () {
    observeChatMessages();
  });

  async function discuss_node() {
    var selected_node = _jm.get_selected_node(); // as parent of new node
    if (!selected_node) {
      prompt_info("please select a node first.");
      return;
    }

    // Call get_children_suggestions function and wait for the response
    const prompt = get_node_discussion_prompt(selected_node, _jm);
    openChatPopup(selected_node, prompt, _jm);
  }
  let curNode = null;
  let prompt_prefix = "";
  async function openChatPopup(_curNode, prompt, _jm) {
    curNode = _curNode;
    backlog = "";
    if (curNode.data.hasOwnProperty("chatlog")) {
      backlog = curNode.data["chatlog"];
    }
    const chatPopup = document.getElementById("chat-popup");
    chatPopup.classList.remove("hidden");

    // Clear existing chat messages
    const chatMessages = document.getElementById("chat-messages");
    chatMessages.innerHTML = "";
    const cur_topic = curNode.topic;
    const hyphenated_list = createHyphenatedList(_jm.get_data().data);
    var prompt_prefix_tmpl = document.getElementById("prefix-prompt").value;
    prompt_prefix = secureEvaluateTemplate(prompt_prefix_tmpl, {
      hyphenated_list: hyphenated_list,
      cur_topic: cur_topic,
    });

    // Display backlog
    if (backlog != "") {
      displayChatMessage(
        "backlog-message",
        "------backlog-----\n" + backlog + "\n----end backlog---"
      );
      displayChatMessage("user-message", "user-message:\n" + prompt_prefix);
    } else {
      // Display prompt
      displayChatMessage("user-message", "user-message:\n" + prompt);

      // Send prompt to GPT and display response
      displayChatMessage(
        "gpt-message",
        "..prompt sent to GPT api, waiting for response.."
      );
      const lastMessage = document.getElementById("chat-messages").lastChild;
      const response = await chatGPTRequest(prompt, curNode);
      lastMessage.innerText = "gpt-message:\n" + response;
    }
    scrollToBottom();
  }

  function closeChatPopup() {
    const chatPopup = document.getElementById("chat-popup");
    chatPopup.classList.add("hidden");
  }

  function displayChatMessage(sender, message) {
    const chatMessages = document.getElementById("chat-messages");
    const messageDiv = document.createElement("div");
    messageDiv.className = sender;
    messageDiv.innerText = message;
    chatMessages.appendChild(messageDiv);
    scrollToBottom();
  }

  // Draggable
  const chatHeader = document.querySelector(".chat-header");
  chatHeader.addEventListener("mousedown", dragMouseDown);

  function dragMouseDown(e) {
    e.preventDefault();

    const chatPopup = document.getElementById("chat-popup");
    const offsetX = e.clientX - chatPopup.getBoundingClientRect().left;
    const offsetY = e.clientY - chatPopup.getBoundingClientRect().top;

    document.onmousemove = (e) => {
      chatPopup.style.left = `${e.clientX - offsetX}px`;
      chatPopup.style.top = `${e.clientY - offsetY}px`;
    };

    document.onmouseup = () => {
      document.onmousemove = null;
      document.onmouseup = null;
    };
  }

  // Resizable
  const resizeHandle = document.querySelector(".resize-handle");
  resizeHandle.addEventListener("mousedown", resizeMouseDown);

  function resizeMouseDown(e) {
    e.preventDefault();

    const chatPopup = document.getElementById("chat-popup");
    const initialWidth = chatPopup.clientWidth;
    const initialHeight = chatPopup.clientHeight;
    const initialX = e.clientX;
    const initialY = e.clientY;

    document.onmousemove = (e) => {
      const newX = e.clientX;
      const newY = e.clientY;

      chatPopup.style.width = `${initialWidth + (newX - initialX)}px`;
      chatPopup.style.height = `${initialHeight + (newY - initialY)}px`;
    };

    document.onmouseup = () => {
      document.onmousemove = null;
      document.onmouseup = null;
    };
  }

  // Multiline input field and ".." waiting indicator
  async function submitChatMessage() {
    const inputText = document.getElementById("chat-input-text");
    const message = inputText.value;
    inputText.value = "";

    if (message.trim() === "") return;

    displayChatMessage("user-message", message);
    displayChatMessage("gpt-message", "..thinking..");
    const lastMessage = document.getElementById("chat-messages").lastChild;
    const response = await chatGPTRequest(prompt_prefix + message, curNode);
    lastMessage.innerText = "gpt-message:\n" + response;
  }
</script>

  </body>
</html>
